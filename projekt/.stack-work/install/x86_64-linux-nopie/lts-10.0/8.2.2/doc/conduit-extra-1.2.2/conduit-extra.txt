-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Batteries included conduit: adapters for common libraries.
--   
--   The conduit package itself maintains relative small dependencies. The
--   purpose of this package is to collect commonly used utility functions
--   wrapping other library dependencies, without depending on
--   heavier-weight dependencies. The basic idea is that this package
--   should only depend on haskell-platform packages and conduit.
@package conduit-extra
@version 1.2.2


-- | Consume attoparsec parsers via conduit.
--   
--   This code was taken from attoparsec-enumerator and adapted for
--   conduits.
module Data.Conduit.Attoparsec

-- | Convert an Attoparsec <a>Parser</a> into a <a>Sink</a>. The parser
--   will be streamed bytes until it returns <a>Done</a> or <a>Fail</a>.
--   
--   If parsing fails, a <a>ParseError</a> will be thrown with
--   <a>monadThrow</a>.
--   
--   Since 0.5.0
sinkParser :: (AttoparsecInput a, MonadThrow m) => Parser a b -> Consumer a m b

-- | Same as <a>sinkParser</a>, but we return an <a>Either</a> type instead
--   of raising an exception.
--   
--   Since 1.1.5
sinkParserEither :: (AttoparsecInput a, Monad m) => Parser a b -> Consumer a m (Either ParseError b)

-- | Consume a stream of parsed tokens, returning both the token and the
--   position it appears at. This function will raise a <a>ParseError</a>
--   on bad input.
--   
--   Since 0.5.0
conduitParser :: (AttoparsecInput a, MonadThrow m) => Parser a b -> Conduit a m (PositionRange, b)

-- | Same as <a>conduitParser</a>, but we return an <a>Either</a> type
--   instead of raising an exception.
conduitParserEither :: (Monad m, AttoparsecInput a) => Parser a b -> Conduit a m (Either ParseError (PositionRange, b))

-- | The context and message from a <a>Fail</a> value.
data ParseError
ParseError :: [String] -> String -> Position -> ParseError
[errorContexts] :: ParseError -> [String]
[errorMessage] :: ParseError -> String
[errorPosition] :: ParseError -> Position
DivergentParser :: ParseError
data Position
Position :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> Position
[posLine] :: Position -> {-# UNPACK #-} !Int
[posCol] :: Position -> {-# UNPACK #-} !Int

[posOffset] :: Position -> {-# UNPACK #-} !Int
data PositionRange
PositionRange :: {-# UNPACK #-} !Position -> {-# UNPACK #-} !Position -> PositionRange
[posRangeStart] :: PositionRange -> {-# UNPACK #-} !Position
[posRangeEnd] :: PositionRange -> {-# UNPACK #-} !Position

-- | A class of types which may be consumed by an Attoparsec parser.
class AttoparsecInput a
instance GHC.Classes.Ord Data.Conduit.Attoparsec.PositionRange
instance GHC.Classes.Eq Data.Conduit.Attoparsec.PositionRange
instance GHC.Show.Show Data.Conduit.Attoparsec.ParseError
instance GHC.Classes.Ord Data.Conduit.Attoparsec.Position
instance GHC.Classes.Eq Data.Conduit.Attoparsec.Position
instance Data.Conduit.Attoparsec.AttoparsecInput Data.ByteString.Internal.ByteString
instance Data.Conduit.Attoparsec.AttoparsecInput Data.Text.Internal.Text
instance GHC.Show.Show Data.Conduit.Attoparsec.PositionRange
instance GHC.Exception.Exception Data.Conduit.Attoparsec.ParseError
instance GHC.Show.Show Data.Conduit.Attoparsec.Position


-- | Functions for interacting with bytes.
--   
--   For many purposes, it's recommended to use the conduit-combinators
--   library, which provides a more complete set of functions.
module Data.Conduit.Binary

-- | Stream the contents of a file as binary data.
--   
--   Since 0.3.0
sourceFile :: MonadResource m => FilePath -> Producer m ByteString

-- | Stream the contents of a <a>Handle</a> as binary data. Note that this
--   function will <i>not</i> automatically close the <tt>Handle</tt> when
--   processing completes, since it did not acquire the <tt>Handle</tt> in
--   the first place.
--   
--   Since 0.3.0
sourceHandle :: MonadIO m => Handle -> Producer m ByteString

-- | Same as <tt>sourceHandle</tt>, but instead of allocating a new buffer
--   for each incoming chunk of data, reuses the same buffer. Therefore,
--   the <tt>ByteString</tt>s yielded by this function are not
--   referentially transparent between two different <tt>yield</tt>s.
--   
--   This function will be slightly more efficient than
--   <tt>sourceHandle</tt> by avoiding allocations and reducing garbage
--   collections, but should only be used if you can guarantee that you do
--   not reuse a <tt>ByteString</tt> (or any slice thereof) between two
--   calls to <tt>await</tt>.
--   
--   Since 1.0.12
sourceHandleUnsafe :: MonadIO m => Handle -> Source m ByteString

-- | An alternative to <a>sourceHandle</a>. Instead of taking a pre-opened
--   <a>Handle</a>, it takes an action that opens a <a>Handle</a> (in read
--   mode), so that it can open it only when needed and close it as soon as
--   possible.
--   
--   Since 0.3.0
sourceIOHandle :: MonadResource m => IO Handle -> Producer m ByteString

-- | Stream the contents of a file as binary data, starting from a certain
--   offset and only consuming up to a certain number of bytes.
--   
--   Since 0.3.0
sourceFileRange :: MonadResource m => FilePath -> Maybe Integer -> Maybe Integer -> Producer m ByteString

-- | Stream the contents of a handle as binary data, starting from a
--   certain offset and only consuming up to a certain number of bytes.
--   
--   Since 1.0.8
sourceHandleRange :: MonadIO m => Handle -> Maybe Integer -> Maybe Integer -> Producer m ByteString

-- | Stream the contents of a handle as binary data, starting from a
--   certain offset and only consuming up to a certain number of bytes.
--   This function consumes chunks as specified by the buffer size.
--   
--   Since 1.1.8
sourceHandleRangeWithBuffer :: MonadIO m => Handle -> Maybe Integer -> Maybe Integer -> Int -> Producer m ByteString

-- | Like <a>withBinaryFile</a>, but provides a source to read bytes from.
withSourceFile :: (MonadUnliftIO m, MonadIO n) => FilePath -> (ConduitM i ByteString n () -> m a) -> m a

-- | Stream all incoming data to the given file.
--   
--   Since 0.3.0
sinkFile :: MonadResource m => FilePath -> Consumer ByteString m ()

-- | Cautious version of <a>sinkFile</a>. The idea here is to stream the
--   values to a temporary file in the same directory of the destination
--   file, and only on successfully writing the entire file, moves it
--   atomically to the destination path.
--   
--   In the event of an exception occurring, the temporary file will be
--   deleted and no move will be made. If the application shuts down
--   without running exception handling (such as machine failure or a
--   SIGKILL), the temporary file will remain and the destination file will
--   be untouched.
sinkFileCautious :: MonadResource m => FilePath -> ConduitM ByteString o m ()

-- | Stream data into a temporary file in the given directory with the
--   given filename pattern, and return the temporary filename. The
--   temporary file will be automatically deleted when exiting the active
--   <tt>ResourceT</tt> block, if it still exists.
sinkTempFile :: MonadResource m => FilePath -> String -> ConduitM ByteString o m FilePath

-- | Same as <a>sinkTempFile</a>, but will use the default temp file
--   directory for the system as the first argument.
sinkSystemTempFile :: MonadResource m => String -> ConduitM ByteString o m FilePath

-- | Stream all incoming data to the given <a>Handle</a>. Note that this
--   function does <i>not</i> flush and will <i>not</i> close the
--   <tt>Handle</tt> when processing completes.
--   
--   Since 0.3.0
sinkHandle :: MonadIO m => Handle -> Consumer ByteString m ()

-- | An alternative to <a>sinkHandle</a>. Instead of taking a pre-opened
--   <a>Handle</a>, it takes an action that opens a <a>Handle</a> (in write
--   mode), so that it can open it only when needed and close it as soon as
--   possible.
--   
--   Since 0.3.0
sinkIOHandle :: MonadResource m => IO Handle -> Consumer ByteString m ()

-- | Stream incoming builders, executing them directly on the buffer of the
--   given <a>Handle</a>. Note that this function does <i>not</i>
--   automatically close the <tt>Handle</tt> when processing completes.
--   Pass <a>flush</a> to flush the buffer.
sinkHandleBuilder :: MonadIO m => Handle -> ConduitM Builder o m ()

-- | Stream incoming <tt>Flush</tt>es, executing them on <tt>IO.Handle</tt>
--   Note that this function does <i>not</i> automatically close the
--   <tt>Handle</tt> when processing completes
sinkHandleFlush :: MonadIO m => Handle -> ConduitM (Flush ByteString) o m ()

-- | Like <a>withBinaryFile</a>, but provides a sink to write bytes to.
withSinkFile :: (MonadUnliftIO m, MonadIO n) => FilePath -> (ConduitM ByteString o n () -> m a) -> m a

-- | Same as <a>withSinkFile</a>, but lets you use a <a>Builder</a>.
withSinkFileBuilder :: (MonadUnliftIO m, MonadIO n) => FilePath -> (ConduitM Builder o n () -> m a) -> m a

-- | Like <a>sinkFileCautious</a>, but uses the <tt>with</tt> pattern
--   instead of <tt>MonadResource</tt>.
withSinkFileCautious :: (MonadUnliftIO m, MonadIO n) => FilePath -> (ConduitM ByteString o n () -> m a) -> m a

-- | Stream the contents of the input to a file, and also send it along the
--   pipeline. Similar in concept to the Unix command <tt>tee</tt>.
--   
--   Since 0.3.0
conduitFile :: MonadResource m => FilePath -> Conduit ByteString m ByteString

-- | Stream the contents of the input to a <tt>Handle</tt>, and also send
--   it along the pipeline. Similar in concept to the Unix command
--   <tt>tee</tt>. Like <tt>sourceHandle</tt>, does not close the handle on
--   completion. Related to: <tt>conduitFile</tt>.
--   
--   Since 1.0.9
conduitHandle :: MonadIO m => Handle -> Conduit ByteString m ByteString

-- | Stream the chunks from a lazy bytestring.
--   
--   Since 0.5.0
sourceLbs :: Monad m => ByteString -> Producer m ByteString

-- | Return the next byte from the stream, if available.
--   
--   Since 0.3.0
head :: Monad m => Consumer ByteString m (Maybe Word8)

-- | Ignore all bytes while the predicate returns <tt>True</tt>.
--   
--   Since 0.3.0
dropWhile :: Monad m => (Word8 -> Bool) -> Consumer ByteString m ()

-- | Take the given number of bytes, if available.
--   
--   Since 0.3.0
take :: Monad m => Int -> Consumer ByteString m ByteString

-- | Drop up to the given number of bytes.
--   
--   Since 0.5.0
drop :: Monad m => Int -> Consumer ByteString m ()

-- | Stream the input data into a temp file and count the number of bytes
--   present. When complete, return a new <tt>Source</tt> reading from the
--   temp file together with the length of the input in bytes.
--   
--   All resources will be cleaned up automatically.
--   
--   Since 1.0.5
sinkCacheLength :: (MonadResource m1, MonadResource m2) => Sink ByteString m1 (Word64, Source m2 ByteString)

-- | Consume a stream of input into a lazy bytestring. Note that no lazy
--   I/O is performed, but rather all content is read into memory strictly.
--   
--   Since 1.0.5
sinkLbs :: Monad m => Sink ByteString m ByteString

-- | Perform a computation on each <tt>Word8</tt> in a stream.
--   
--   Since 1.0.10
mapM_ :: Monad m => (Word8 -> m ()) -> Consumer ByteString m ()

-- | Consume some instance of <tt>Storable</tt> from the incoming byte
--   stream. In the event of insufficient bytes in the stream, returns a
--   <tt>Nothing</tt> and returns all unused input as leftovers.
sinkStorable :: (Monad m, Storable a) => Consumer ByteString m (Maybe a)

-- | Same as <a>sinkStorable</a>, but throws a
--   <a>SinkStorableInsufficientBytes</a> exception (via <a>throwM</a>) in
--   the event of insufficient bytes. This can be more efficient to use
--   than <a>sinkStorable</a> as it avoids the need to
--   construct/deconstruct a <tt>Maybe</tt> wrapper in the success case.
sinkStorableEx :: (MonadThrow m, Storable a) => Consumer ByteString m a

-- | Ensure that only up to the given number of bytes are consumed by the
--   inner sink. Note that this does <i>not</i> ensure that all of those
--   bytes are in fact consumed.
--   
--   Since 0.3.0
isolate :: Monad m => Int -> Conduit ByteString m ByteString

-- | Return all bytes while the predicate returns <tt>True</tt>.
--   
--   Since 0.3.0
takeWhile :: Monad m => (Word8 -> Bool) -> Conduit ByteString m ByteString

-- | Split the input bytes into lines. In other words, split on the LF byte
--   (10), and strip it from the output.
--   
--   Since 0.3.0
lines :: Monad m => Conduit ByteString m ByteString
instance GHC.Show.Show Data.Conduit.Binary.SinkStorableException
instance GHC.Exception.Exception Data.Conduit.Binary.SinkStorableException


-- | Convert a stream of blaze-builder <tt>Builder</tt>s into a stream of
--   <tt>ByteString</tt>s.
--   
--   Works with both blaze-builder &lt; 0.4's <tt>Builder</tt>s and
--   <a>Builder</a>.
--   
--   Adapted from blaze-builder-enumerator, written by myself and Simon
--   Meier.
--   
--   Note that the functions here can work in any monad built on top of
--   <tt>IO</tt> or <tt>ST</tt>.
--   
--   Since 1.1.7.0
module Data.Conduit.ByteString.Builder

-- | Incrementally execute builders and pass on the filled chunks as
--   bytestrings.
builderToByteString :: (MonadBase base m, PrimMonad base, StreamingBuilder b) => Conduit b m ByteString

-- | Incrementally execute builders on the given buffer and pass on the
--   filled chunks as bytestrings. Note that, if the given buffer is too
--   small for the execution of a build step, a larger one will be
--   allocated.
--   
--   WARNING: This conduit yields bytestrings that are NOT referentially
--   transparent. Their content will be overwritten as soon as control is
--   returned from the inner sink!
unsafeBuilderToByteString :: (MonadBase base m, PrimMonad base, StreamingBuilder b) => IO Buffer -> Conduit b m ByteString

-- | A conduit that incrementally executes builders and passes on the
--   filled chunks as bytestrings to an inner sink.
--   
--   INV: All bytestrings passed to the inner sink are non-empty.
builderToByteStringWith :: (MonadBase base m, PrimMonad base, StreamingBuilder b) => BufferAllocStrategy -> Conduit b m ByteString

-- | Since 0.0.2
builderToByteStringFlush :: (MonadBase base m, PrimMonad base, StreamingBuilder b) => Conduit (Flush b) m (Flush ByteString)

-- | Since 0.0.2
builderToByteStringWithFlush :: (MonadBase base m, PrimMonad base, StreamingBuilder b) => BufferAllocStrategy -> Conduit (Flush b) m (Flush ByteString)

-- | A buffer <tt>Buffer fpbuf p0 op ope</tt> describes a buffer with the
--   underlying byte array <tt>fpbuf..ope</tt>, the currently written slice
--   <tt>p0..op</tt> and the free space <tt>op..ope</tt>.
--   
--   Since 0.1.10.0
data Buffer :: *

-- | The size of the free space of the buffer.
--   
--   Since 0.1.10.0
freeSize :: Buffer -> Int

-- | The size of the written slice in the buffer.
--   
--   Since 0.1.10.0
sliceSize :: Buffer -> Int

-- | The size of the whole byte array underlying the buffer.
--   
--   Since 0.1.10.0
bufferSize :: Buffer -> Int

-- | <tt>allocBuffer size</tt> allocates a new buffer of size
--   <tt>size</tt>.
--   
--   Since 0.1.10.0
allocBuffer :: Int -> IO Buffer

-- | Resets the beginning of the next slice and the next free byte such
--   that the whole buffer can be filled again.
--   
--   Since 0.1.10.0
reuseBuffer :: Buffer -> Buffer

-- | Move the beginning of the slice to the next free byte such that the
--   remaining free space of the buffer can be filled further. This
--   operation is safe and can be used to fill the remaining part of the
--   buffer after a direct insertion of a bytestring or a flush.
--   
--   Since 0.1.10.0
nextSlice :: Int -> Buffer -> Maybe Buffer

-- | Convert the buffer to a bytestring. This operation is unsafe in the
--   sense that created bytestring shares the underlying byte array with
--   the buffer. Hence, depending on the later use of this buffer (e.g., if
--   it gets reset and filled again) referential transparency may be lost.
--   
--   Since 0.1.10.0
unsafeFreezeBuffer :: Buffer -> ByteString

-- | Convert a buffer to a non-empty bytestring. See
--   <a>unsafeFreezeBuffer</a> for the explanation of why this operation
--   may be unsafe.
--   
--   Since 0.1.10.0
unsafeFreezeNonEmptyBuffer :: Buffer -> Maybe ByteString

-- | A buffer allocation strategy <tt>(buf0, nextBuf)</tt> specifies the
--   initial buffer to use and how to compute a new buffer <tt>nextBuf
--   minSize buf</tt> with at least size <tt>minSize</tt> from a filled
--   buffer <tt>buf</tt>. The double nesting of the <tt>IO</tt> monad helps
--   to ensure that the reference to the filled buffer <tt>buf</tt> is lost
--   as soon as possible, but the new buffer doesn't have to be allocated
--   too early.
--   
--   Since 0.1.10.0
type BufferAllocStrategy = (IO Buffer, Int -> Buffer -> IO IO Buffer)

-- | The simplest buffer allocation strategy: whenever a buffer is
--   requested, allocate a new one that is big enough for the next build
--   step to execute.
--   
--   NOTE that this allocation strategy may spill quite some memory upon
--   direct insertion of a bytestring by the builder. Thats no problem for
--   garbage collection, but it may lead to unreasonably high memory
--   consumption in special circumstances.
--   
--   Since 0.1.10.0
allNewBuffersStrategy :: Int -> BufferAllocStrategy

-- | An unsafe, but possibly more efficient buffer allocation strategy:
--   reuse the buffer, if it is big enough for the next build step to
--   execute.
--   
--   Since 0.1.10.0
reuseBufferStrategy :: IO Buffer -> BufferAllocStrategy


-- | Convert a stream of blaze-builder <tt>Builder</tt>s into a stream of
--   <tt>ByteString</tt>s.
--   
--   Adapted from blaze-builder-enumerator, written by myself and Simon
--   Meier.
--   
--   Note that the functions here can work in any monad built on top of
--   <tt>IO</tt> or <tt>ST</tt>.
--   
--   Since 1.1.7.0, the functions here call their counterparts in
--   <a>Data.Conduit.ByteString.Builder</a>, which work with both
--   <a>Builder</a> and blaze-builder 0.3's <a>Builder</a>.
module Data.Conduit.Blaze

-- | Incrementally execute builders and pass on the filled chunks as
--   bytestrings.
builderToByteString :: (MonadBase base m, PrimMonad base) => Conduit Builder m ByteString

-- | Incrementally execute builders on the given buffer and pass on the
--   filled chunks as bytestrings. Note that, if the given buffer is too
--   small for the execution of a build step, a larger one will be
--   allocated.
--   
--   WARNING: This conduit yields bytestrings that are NOT referentially
--   transparent. Their content will be overwritten as soon as control is
--   returned from the inner sink!
unsafeBuilderToByteString :: (MonadBase base m, PrimMonad base) => IO Buffer -> Conduit Builder m ByteString

-- | A conduit that incrementally executes builders and passes on the
--   filled chunks as bytestrings to an inner sink.
--   
--   INV: All bytestrings passed to the inner sink are non-empty.
builderToByteStringWith :: (MonadBase base m, PrimMonad base) => BufferAllocStrategy -> Conduit Builder m ByteString

-- | Since 0.0.2
builderToByteStringFlush :: (MonadBase base m, PrimMonad base) => Conduit (Flush Builder) m (Flush ByteString)

-- | Since 0.0.2
builderToByteStringWithFlush :: (MonadBase base m, PrimMonad base) => BufferAllocStrategy -> Conduit (Flush Builder) m (Flush ByteString)

-- | A buffer <tt>Buffer fpbuf p0 op ope</tt> describes a buffer with the
--   underlying byte array <tt>fpbuf..ope</tt>, the currently written slice
--   <tt>p0..op</tt> and the free space <tt>op..ope</tt>.
--   
--   Since 0.1.10.0
data Buffer :: *

-- | The size of the free space of the buffer.
--   
--   Since 0.1.10.0
freeSize :: Buffer -> Int

-- | The size of the written slice in the buffer.
--   
--   Since 0.1.10.0
sliceSize :: Buffer -> Int

-- | The size of the whole byte array underlying the buffer.
--   
--   Since 0.1.10.0
bufferSize :: Buffer -> Int

-- | <tt>allocBuffer size</tt> allocates a new buffer of size
--   <tt>size</tt>.
--   
--   Since 0.1.10.0
allocBuffer :: Int -> IO Buffer

-- | Resets the beginning of the next slice and the next free byte such
--   that the whole buffer can be filled again.
--   
--   Since 0.1.10.0
reuseBuffer :: Buffer -> Buffer

-- | Move the beginning of the slice to the next free byte such that the
--   remaining free space of the buffer can be filled further. This
--   operation is safe and can be used to fill the remaining part of the
--   buffer after a direct insertion of a bytestring or a flush.
--   
--   Since 0.1.10.0
nextSlice :: Int -> Buffer -> Maybe Buffer

-- | Convert the buffer to a bytestring. This operation is unsafe in the
--   sense that created bytestring shares the underlying byte array with
--   the buffer. Hence, depending on the later use of this buffer (e.g., if
--   it gets reset and filled again) referential transparency may be lost.
--   
--   Since 0.1.10.0
unsafeFreezeBuffer :: Buffer -> ByteString

-- | Convert a buffer to a non-empty bytestring. See
--   <a>unsafeFreezeBuffer</a> for the explanation of why this operation
--   may be unsafe.
--   
--   Since 0.1.10.0
unsafeFreezeNonEmptyBuffer :: Buffer -> Maybe ByteString

-- | A buffer allocation strategy <tt>(buf0, nextBuf)</tt> specifies the
--   initial buffer to use and how to compute a new buffer <tt>nextBuf
--   minSize buf</tt> with at least size <tt>minSize</tt> from a filled
--   buffer <tt>buf</tt>. The double nesting of the <tt>IO</tt> monad helps
--   to ensure that the reference to the filled buffer <tt>buf</tt> is lost
--   as soon as possible, but the new buffer doesn't have to be allocated
--   too early.
--   
--   Since 0.1.10.0
type BufferAllocStrategy = (IO Buffer, Int -> Buffer -> IO IO Buffer)

-- | The simplest buffer allocation strategy: whenever a buffer is
--   requested, allocate a new one that is big enough for the next build
--   step to execute.
--   
--   NOTE that this allocation strategy may spill quite some memory upon
--   direct insertion of a bytestring by the builder. Thats no problem for
--   garbage collection, but it may lead to unreasonably high memory
--   consumption in special circumstances.
--   
--   Since 0.1.10.0
allNewBuffersStrategy :: Int -> BufferAllocStrategy

-- | An unsafe, but possibly more efficient buffer allocation strategy:
--   reuse the buffer, if it is big enough for the next build step to
--   execute.
--   
--   Since 0.1.10.0
reuseBufferStrategy :: IO Buffer -> BufferAllocStrategy

module Data.Conduit.Filesystem

-- | Stream the contents of the given directory, without traversing deeply.
--   
--   This function will return <i>all</i> of the contents of the directory,
--   whether they be files, directories, etc.
--   
--   Note that the generated filepaths will be the complete path, not just
--   the filename. In other words, if you have a directory <tt>foo</tt>
--   containing files <tt>bar</tt> and <tt>baz</tt>, and you use
--   <tt>sourceDirectory</tt> on <tt>foo</tt>, the results will be
--   <tt>foo/bar</tt> and <tt>foo/baz</tt>.
--   
--   Since 1.1.0
sourceDirectory :: MonadResource m => FilePath -> Producer m FilePath

-- | Deeply stream the contents of the given directory.
--   
--   This works the same as <tt>sourceDirectory</tt>, but will not return
--   directories at all. This function also takes an extra parameter to
--   indicate whether symlinks will be followed.
--   
--   Since 1.1.0
sourceDirectoryDeep :: MonadResource m => Bool -> FilePath -> Producer m FilePath


-- | Adapter module to work with the <a>foldl</a> package.
module Data.Conduit.Foldl

-- | Convert a left fold into a <a>Consumer</a>. This function is intended
--   to be used with <tt>purely</tt> from the <a>foldl</a> package.
sinkFold :: Monad m => (x -> a -> x) -> x -> (x -> b) -> Consumer a m b

-- | Convert a monadic left fold into a <a>Consumer</a>. This function is
--   intended to be used with <tt>impurely</tt> from the <a>foldl</a>
--   package.
sinkFoldM :: Monad m => (x -> a -> m x) -> m x -> (x -> m b) -> Consumer a m b


-- | Use lazy I/O for consuming the contents of a source. Warning: All
--   normal warnings of lazy I/O apply. In particular, if you are using
--   this with a <tt>ResourceT</tt> transformer, you must force the list to
--   be evaluated before exiting the <tt>ResourceT</tt>.
module Data.Conduit.Lazy

-- | Use lazy I/O to consume all elements from a <tt>Source</tt>.
--   
--   This function relies on <a>monadActive</a> to determine if the
--   underlying monadic state has been closed.
--   
--   Since 0.3.0
lazyConsume :: (MonadBaseControl IO m, MonadActive m) => Source m a -> m [a]

-- | Determine if some monad is still active. This is intended to prevent
--   usage of a monadic state after it has been closed. This is necessary
--   for such cases as lazy I/O, where an unevaluated thunk may still refer
--   to a closed <tt>ResourceT</tt>.
--   
--   Since 0.3.0
class Monad m => MonadActive m
monadActive :: MonadActive m => m Bool
instance (Control.Monad.IO.Class.MonadIO m, Data.Conduit.Lazy.MonadActive m) => Data.Conduit.Lazy.MonadActive (Control.Monad.Trans.Resource.Internal.ResourceT m)
instance Data.Conduit.Lazy.MonadActive Data.Functor.Identity.Identity
instance Data.Conduit.Lazy.MonadActive GHC.Types.IO
instance Data.Conduit.Lazy.MonadActive (GHC.ST.ST s)
instance Data.Conduit.Lazy.MonadActive (Control.Monad.ST.Lazy.Imp.ST s)
instance Data.Conduit.Lazy.MonadActive m => Data.Conduit.Lazy.MonadActive (Control.Monad.Trans.Identity.IdentityT m)
instance Data.Conduit.Lazy.MonadActive m => Data.Conduit.Lazy.MonadActive (Control.Monad.Trans.List.ListT m)
instance Data.Conduit.Lazy.MonadActive m => Data.Conduit.Lazy.MonadActive (Control.Monad.Trans.Maybe.MaybeT m)
instance (Control.Monad.Trans.Error.Error e, Data.Conduit.Lazy.MonadActive m) => Data.Conduit.Lazy.MonadActive (Control.Monad.Trans.Error.ErrorT e m)
instance Data.Conduit.Lazy.MonadActive m => Data.Conduit.Lazy.MonadActive (Control.Monad.Trans.Reader.ReaderT r m)
instance Data.Conduit.Lazy.MonadActive m => Data.Conduit.Lazy.MonadActive (Control.Monad.Trans.State.Lazy.StateT s m)
instance (GHC.Base.Monoid w, Data.Conduit.Lazy.MonadActive m) => Data.Conduit.Lazy.MonadActive (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Base.Monoid w, Data.Conduit.Lazy.MonadActive m) => Data.Conduit.Lazy.MonadActive (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (GHC.Base.Monoid w, Data.Conduit.Lazy.MonadActive m) => Data.Conduit.Lazy.MonadActive (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Data.Conduit.Lazy.MonadActive m => Data.Conduit.Lazy.MonadActive (Control.Monad.Trans.State.Strict.StateT s m)
instance (GHC.Base.Monoid w, Data.Conduit.Lazy.MonadActive m) => Data.Conduit.Lazy.MonadActive (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance Data.Conduit.Lazy.MonadActive m => Data.Conduit.Lazy.MonadActive (Data.Conduit.Internal.Pipe.Pipe l i o u m)
instance Data.Conduit.Lazy.MonadActive m => Data.Conduit.Lazy.MonadActive (Data.Conduit.Internal.Conduit.ConduitM i o m)

module Data.Conduit.Network

-- | Stream data from the socket.
--   
--   This function does <i>not</i> automatically close the socket.
--   
--   Since 0.0.0
sourceSocket :: MonadIO m => Socket -> Producer m ByteString

-- | Stream data to the socket.
--   
--   This function does <i>not</i> automatically close the socket.
--   
--   Since 0.0.0
sinkSocket :: MonadIO m => Socket -> Consumer ByteString m ()

-- | The data passed to an <tt>Application</tt>.
data AppData :: *
appSource :: (HasReadWrite ad, MonadIO m) => ad -> Producer m ByteString
appSink :: (HasReadWrite ad, MonadIO m) => ad -> Consumer ByteString m ()
appSockAddr :: AppData -> SockAddr
appLocalAddr :: AppData -> Maybe SockAddr

-- | Settings for a TCP server. It takes a port to listen on, and an
--   optional hostname to bind to.
data ServerSettings :: *
serverSettings :: Int -> HostPreference -> ServerSettings

-- | Run an <tt>Application</tt> with the given settings. This function
--   will create a new listening socket, accept connections on it, and
--   spawn a new thread for each connection.
runTCPServer :: () => ServerSettings -> (AppData -> IO ()) -> IO a
runTCPServerWithHandle :: () => ServerSettings -> ConnectionHandle -> IO a

-- | Fork a TCP Server
--   
--   Will fork the runGeneralTCPServer function but will only return from
--   this call when the server is bound to the port and accepting incoming
--   connections. Will return the thread id of the server
--   
--   Since 1.1.4
forkTCPServer :: MonadBaseControl IO m => ServerSettings -> (AppData -> m ()) -> m ThreadId

-- | Run a general TCP server
--   
--   Same as <a>runTCPServer</a>, except monad can be any instance of
--   <a>MonadBaseControl</a> <a>IO</a>.
--   
--   Note that any changes to the monadic state performed by individual
--   client handlers will be discarded. If you have mutable state you want
--   to share among multiple handlers, you need to use some kind of mutable
--   variables.
--   
--   Since 1.1.3
runGeneralTCPServer :: MonadBaseControl IO m => ServerSettings -> (AppData -> m ()) -> m a

-- | Settings for a TCP client, specifying how to connect to the server.
data ClientSettings :: *
clientSettings :: Int -> ByteString -> ClientSettings

-- | Run an <tt>Application</tt> by connecting to the specified server.
runTCPClient :: () => ClientSettings -> (AppData -> IO a) -> IO a

-- | Run a general TCP client
--   
--   Same as <a>runTCPClient</a>, except monad can be any instance of
--   <a>MonadBaseControl</a> <a>IO</a>.
--   
--   Since 1.1.3
runGeneralTCPClient :: MonadBaseControl IO m => ClientSettings -> (AppData -> m a) -> m a
getPort :: HasPort a => a -> Int
getHost :: ClientSettings -> ByteString
getAfterBind :: HasAfterBind a => a -> Socket -> IO ()
getNeedLocalAddr :: ServerSettings -> Bool
setPort :: HasPort a => Int -> a -> a
setHost :: ByteString -> ClientSettings -> ClientSettings
setAfterBind :: HasAfterBind a => (Socket -> IO ()) -> a -> a
setNeedLocalAddr :: Bool -> ServerSettings -> ServerSettings

-- | Which host to bind.
--   
--   Note: The <tt>IsString</tt> instance recognizes the following special
--   values:
--   
--   <ul>
--   <li><tt>*</tt> means <tt>HostAny</tt> - "any IPv4 or IPv6
--   hostname"</li>
--   <li><tt>*4</tt> means <tt>HostIPv4</tt> - "any IPv4 or IPv6 hostname,
--   IPv4 preferred"</li>
--   <li><tt>!4</tt> means <tt>HostIPv4Only</tt> - "any IPv4 hostname"</li>
--   <li><tt>*6</tt> means <tt>HostIPv6</tt>@ - "any IPv4 or IPv6 hostname,
--   IPv6 preferred"</li>
--   <li><tt>!6</tt> means <tt>HostIPv6Only</tt> - "any IPv6 hostname"</li>
--   </ul>
--   
--   Note that the permissive <tt>*</tt> values allow binding to an IPv4 or
--   an IPv6 hostname, which means you might be able to successfully bind
--   to a port more times than you expect (eg once on the IPv4 localhost
--   127.0.0.1 and again on the IPv6 localhost 0:0:0:0:0:0:0:1).
--   
--   Any other value is treated as a hostname. As an example, to bind to
--   the IPv4 local host only, use "127.0.0.1".
data HostPreference :: *

module Data.Conduit.Network.UDP

-- | Representation of a single UDP message
data Message :: *
Message :: {-# UNPACK #-} !ByteString -> !SockAddr -> Message
[msgData] :: Message -> {-# UNPACK #-} !ByteString
[msgSender] :: Message -> !SockAddr

-- | Stream messages from the socket.
--   
--   The given <tt>len</tt> defines the maximum packet size. Every produced
--   item contains the message payload and the origin address.
--   
--   This function does <i>not</i> automatically close the socket.
sourceSocket :: MonadIO m => Socket -> Int -> Producer m Message

-- | Stream messages to the connected socket.
--   
--   The payload is sent using <tt>send</tt>, so some of it might be lost.
--   
--   This function does <i>not</i> automatically close the socket.
sinkSocket :: MonadIO m => Socket -> Consumer ByteString m ()

-- | Stream messages to the connected socket.
--   
--   The payload is sent using <tt>sendAll</tt>, so it might end up in
--   multiple packets.
--   
--   This function does <i>not</i> automatically close the socket.
sinkAllSocket :: MonadIO m => Socket -> Consumer ByteString m ()

-- | Stream messages to the socket.
--   
--   Every handled item contains the message payload and the destination
--   address. The payload is sent using <tt>sendTo</tt>, so some of it
--   might be lost.
--   
--   This function does <i>not</i> automatically close the socket.
sinkToSocket :: MonadIO m => Socket -> Consumer Message m ()

-- | Stream messages to the socket.
--   
--   Every handled item contains the message payload and the destination
--   address. The payload is sent using <tt>sendAllTo</tt>, so it might end
--   up in multiple packets.
--   
--   This function does <i>not</i> automatically close the socket.
sinkAllToSocket :: MonadIO m => Socket -> Consumer Message m ()

-- | Which host to bind.
--   
--   Note: The <tt>IsString</tt> instance recognizes the following special
--   values:
--   
--   <ul>
--   <li><tt>*</tt> means <tt>HostAny</tt> - "any IPv4 or IPv6
--   hostname"</li>
--   <li><tt>*4</tt> means <tt>HostIPv4</tt> - "any IPv4 or IPv6 hostname,
--   IPv4 preferred"</li>
--   <li><tt>!4</tt> means <tt>HostIPv4Only</tt> - "any IPv4 hostname"</li>
--   <li><tt>*6</tt> means <tt>HostIPv6</tt>@ - "any IPv4 or IPv6 hostname,
--   IPv6 preferred"</li>
--   <li><tt>!6</tt> means <tt>HostIPv6Only</tt> - "any IPv6 hostname"</li>
--   </ul>
--   
--   Note that the permissive <tt>*</tt> values allow binding to an IPv4 or
--   an IPv6 hostname, which means you might be able to successfully bind
--   to a port more times than you expect (eg once on the IPv4 localhost
--   127.0.0.1 and again on the IPv6 localhost 0:0:0:0:0:0:0:1).
--   
--   Any other value is treated as a hostname. As an example, to bind to
--   the IPv4 local host only, use "127.0.0.1".
data HostPreference :: *

module Data.Conduit.Network.Unix

-- | Stream data from the socket.
--   
--   This function does <i>not</i> automatically close the socket.
--   
--   Since 0.0.0
sourceSocket :: MonadIO m => Socket -> Producer m ByteString

-- | Stream data to the socket.
--   
--   This function does <i>not</i> automatically close the socket.
--   
--   Since 0.0.0
sinkSocket :: MonadIO m => Socket -> Consumer ByteString m ()

-- | The data passed to a Unix domain sockets <tt>Application</tt>.
data AppDataUnix :: *
appSource :: (HasReadWrite ad, MonadIO m) => ad -> Producer m ByteString
appSink :: (HasReadWrite ad, MonadIO m) => ad -> Consumer ByteString m ()

-- | Settings for a Unix domain sockets server.
data ServerSettingsUnix :: *
serverSettings :: FilePath -> ServerSettingsUnix

-- | Run an <tt>Application</tt> with the given settings. This function
--   will create a new listening socket, accept connections on it, and
--   spawn a new thread for each connection.
runUnixServer :: () => ServerSettingsUnix -> (AppDataUnix -> IO ()) -> IO a

-- | Settings for a Unix domain sockets client.
data ClientSettingsUnix :: *
clientSettings :: FilePath -> ClientSettingsUnix

-- | Run an <tt>Application</tt> by connecting to the specified server.
runUnixClient :: () => ClientSettingsUnix -> (AppDataUnix -> IO a) -> IO a
getPath :: HasPath a => a -> FilePath
getAfterBind :: HasAfterBind a => a -> Socket -> IO ()
setPath :: HasPath a => FilePath -> a -> a
setAfterBind :: HasAfterBind a => (Socket -> IO ()) -> a -> a


-- | A full tutorial for this module is available at:
--   <a>https://github.com/snoyberg/conduit/blob/master/PROCESS.md</a>.
--   
--   Note that this is a very thin layer around the
--   <tt>Data.Streaming.Process</tt> module. In particular, it:
--   
--   <ul>
--   <li>Provides orphan instances for conduit</li>
--   <li>Provides some useful helper functions</li>
--   </ul>
module Data.Conduit.Process

-- | Like <tt>sourceProcessWithConsumer</tt> but providing the command to
--   be run as a <tt>String</tt>.
--   
--   Since 1.1.2
sourceCmdWithConsumer :: MonadIO m => String -> Consumer ByteString m a -> m (ExitCode, a)

-- | Given a <tt>CreateProcess</tt>, run the process, with its output being
--   used as a <tt>Source</tt> to feed the provided <tt>Consumer</tt>. Once
--   the process has completed, return a tuple of the <tt>ExitCode</tt>
--   from the process and the output collected from the <tt>Consumer</tt>.
--   
--   Note that, if an exception is raised by the consumer, the process is
--   <i>not</i> terminated. This behavior is different from
--   <a>sourceProcessWithStreams</a> due to historical reasons.
--   
--   Since 1.1.2
sourceProcessWithConsumer :: MonadIO m => CreateProcess -> Consumer ByteString m a -> m (ExitCode, a)

-- | Like <tt>sourceProcessWithStreams</tt> but providing the command to be
--   run as a <tt>String</tt>.
sourceCmdWithStreams :: String -> Producer IO ByteString -> Consumer ByteString IO a -> Consumer ByteString IO b -> IO (ExitCode, a, b)

-- | Given a <tt>CreateProcess</tt>, run the process and feed the provided
--   <tt>Producer</tt> to the stdin <tt>Sink</tt> of the process. Use the
--   process outputs (stdout, stderr) as <tt>Source</tt>s and feed it to
--   the provided <tt>Consumer</tt>s. Once the process has completed,
--   return a tuple of the <tt>ExitCode</tt> from the process and the
--   results collected from the <tt>Consumer</tt>s.
--   
--   If an exception is raised by any of the streams, the process is
--   terminated.
--   
--   IO is required because the streams are run concurrently using the
--   <a>async</a> package
sourceProcessWithStreams :: CreateProcess -> Producer IO ByteString -> Consumer ByteString IO a -> Consumer ByteString IO b -> IO (ExitCode, a, b)

-- | Same as <a>withCheckedProcess</a>, but kills the child process in the
--   case of an exception being thrown by the provided callback function.
withCheckedProcessCleanup :: (InputSource stdin, OutputSink stderr, OutputSink stdout, MonadIO m, MonadMask m) => CreateProcess -> (stdin -> stdout -> stderr -> m b) -> m b
instance (Control.Monad.IO.Class.MonadIO m, r ~ ()) => Data.Streaming.Process.Internal.InputSource (Data.Conduit.Process.FlushInput o m r)
instance (Control.Monad.IO.Class.MonadIO m, Control.Monad.IO.Class.MonadIO n, r ~ (), r' ~ ()) => Data.Streaming.Process.Internal.InputSource (Data.Conduit.Process.FlushInput o m r, n r')
instance (Control.Monad.IO.Class.MonadIO m, r ~ ()) => Data.Streaming.Process.Internal.InputSource (Data.Conduit.Process.BuilderInput o m r)
instance (Control.Monad.IO.Class.MonadIO m, Control.Monad.IO.Class.MonadIO n, r ~ (), r' ~ ()) => Data.Streaming.Process.Internal.InputSource (Data.Conduit.Process.BuilderInput o m r, n r')
instance (r ~ (), Control.Monad.IO.Class.MonadIO m, i ~ Data.ByteString.Internal.ByteString) => Data.Streaming.Process.Internal.InputSource (Data.Conduit.Internal.Conduit.ConduitM i o m r)
instance (r ~ (), r' ~ (), Control.Monad.IO.Class.MonadIO m, Control.Monad.IO.Class.MonadIO n, i ~ Data.ByteString.Internal.ByteString) => Data.Streaming.Process.Internal.InputSource (Data.Conduit.Internal.Conduit.ConduitM i o m r, n r')
instance (r ~ (), Control.Monad.IO.Class.MonadIO m, o ~ Data.ByteString.Internal.ByteString) => Data.Streaming.Process.Internal.OutputSink (Data.Conduit.Internal.Conduit.ConduitM i o m r)
instance (r ~ (), r' ~ (), Control.Monad.IO.Class.MonadIO m, Control.Monad.IO.Class.MonadIO n, o ~ Data.ByteString.Internal.ByteString) => Data.Streaming.Process.Internal.OutputSink (Data.Conduit.Internal.Conduit.ConduitM i o m r, n r')


-- | The <a>System.Process.Typed</a> module from <tt>typed-process</tt>,
--   but with added conduit helpers.
module Data.Conduit.Process.Typed

-- | Provide input to a process by writing to a conduit.
createSink :: MonadIO m => StreamSpec  'STInput (ConduitM ByteString o m ())

-- | Read output from a process by read from a conduit.
createSource :: MonadIO m => StreamSpec  'STOutput (ConduitM i ByteString m ())

-- | Same as <a>withProcess</a>, but generalized to <a>MonadUnliftIO</a>.
withProcess :: MonadUnliftIO m => ProcessConfig stdin stdout stderr -> (Process stdin stdout stderr -> m a) -> m a

-- | Same as <a>withProcess_</a>, but generalized to <a>MonadUnliftIO</a>.
withProcess_ :: MonadUnliftIO m => ProcessConfig stdin stdout stderr -> (Process stdin stdout stderr -> m a) -> m a


-- | Handle streams of text.
--   
--   Parts of this code were taken from enumerator and adapted for
--   conduits.
--   
--   For many purposes, it's recommended to use the conduit-combinators
--   library, which provides a more complete set of functions.
module Data.Conduit.Text

-- | A specific character encoding.
--   
--   Since 0.3.0
data Codec

-- | Convert text into bytes, using the provided codec. If the codec is not
--   capable of representing an input character, an exception will be
--   thrown.
--   
--   Since 0.3.0
encode :: MonadThrow m => Codec -> Conduit Text m ByteString

-- | Convert bytes into text, using the provided codec. If the codec is not
--   capable of decoding an input byte sequence, an exception will be
--   thrown.
--   
--   Since 0.3.0
decode :: MonadThrow m => Codec -> Conduit ByteString m Text

-- | Since 0.3.0
utf8 :: Codec

-- | Since 0.3.0
utf16_le :: Codec

-- | Since 0.3.0
utf16_be :: Codec

-- | Since 0.3.0
utf32_le :: Codec

-- | Since 0.3.0
utf32_be :: Codec

-- | Since 0.3.0
ascii :: Codec

-- | Since 0.3.0
iso8859_1 :: Codec

-- | Emit each line separately
--   
--   Since 0.4.1
lines :: Monad m => Conduit Text m Text

-- | Variant of the lines function with an integer parameter. The text
--   length of any emitted line never exceeds the value of the parameter.
--   Whenever this is about to happen a LengthExceeded exception is thrown.
--   This function should be used instead of the lines function whenever we
--   are dealing with user input (e.g. a file upload) because we can't be
--   sure that user input won't have extraordinarily large lines which
--   would require large amounts of memory if consumed.
linesBounded :: MonadThrow m => Int -> Conduit Text m Text

-- | Since 0.3.0
data TextException
DecodeException :: Codec -> Word8 -> TextException
EncodeException :: Codec -> Char -> TextException
LengthExceeded :: Int -> TextException
TextException :: SomeException -> TextException
NewDecodeException :: !Text -> !Int -> !ByteString -> TextException

-- | Since 1.0.8
takeWhile :: Monad m => (Char -> Bool) -> Conduit Text m Text

-- | Since 1.0.8
dropWhile :: Monad m => (Char -> Bool) -> Consumer Text m ()

-- | Since 1.0.8
take :: Monad m => Int -> Conduit Text m Text

-- | Since 1.0.8
drop :: Monad m => Int -> Consumer Text m ()

-- | Since 1.0.8
foldLines :: Monad m => (a -> ConduitM Text o m a) -> a -> ConduitM Text o m a

-- | Since 1.0.8
withLine :: Monad m => Sink Text m a -> Consumer Text m (Maybe a)

-- | Decode a stream of UTF8-encoded bytes into a stream of text, throwing
--   an exception on invalid input.
--   
--   Since 1.0.15
decodeUtf8 :: MonadThrow m => Conduit ByteString m Text

-- | Decode a stream of UTF8 data, and replace invalid bytes with the
--   Unicode replacement character.
--   
--   Since 1.1.1
decodeUtf8Lenient :: Monad m => Conduit ByteString m Text

-- | Encode a stream of text into a stream of bytes.
--   
--   Since 1.0.15
encodeUtf8 :: Monad m => Conduit Text m ByteString

-- | Automatically determine which UTF variant is being used. This function
--   checks for BOMs, removing them as necessary. It defaults to assuming
--   UTF-8.
--   
--   Since 1.1.9
detectUtf :: MonadThrow m => Conduit ByteString m Text
instance GHC.Show.Show Data.Conduit.Text.Codec
instance GHC.Show.Show Data.Conduit.Text.TextException
instance GHC.Exception.Exception Data.Conduit.Text.TextException


-- | Streaming compression and decompression using conduits.
--   
--   Parts of this code were taken from zlib-enum and adapted for conduits.
module Data.Conduit.Zlib

-- | Compress (deflate) a stream of <a>ByteString</a>s. The
--   <a>WindowBits</a> also control the format (zlib vs. gzip).
compress :: (MonadBase base m, PrimMonad base, MonadThrow m) => Int -> WindowBits -> Conduit ByteString m ByteString

-- | Decompress (inflate) a stream of <a>ByteString</a>s. For example:
--   
--   <pre>
--   sourceFile "test.z" $= decompress defaultWindowBits $$ sinkFile "test"
--   </pre>
decompress :: (MonadBase base m, PrimMonad base, MonadThrow m) => WindowBits -> Conduit ByteString m ByteString

-- | Gzip compression with default parameters.
gzip :: (MonadThrow m, MonadBase base m, PrimMonad base) => Conduit ByteString m ByteString

-- | Gzip decompression with default parameters.
ungzip :: (MonadBase base m, PrimMonad base, MonadThrow m) => Conduit ByteString m ByteString

-- | Same as <a>compress</a>, but allows you to explicitly flush the
--   stream.
compressFlush :: (MonadBase base m, PrimMonad base, MonadThrow m) => Int -> WindowBits -> Conduit (Flush ByteString) m (Flush ByteString)

-- | Same as <a>decompress</a>, but allows you to explicitly flush the
--   stream.
decompressFlush :: (MonadBase base m, PrimMonad base, MonadThrow m) => WindowBits -> Conduit (Flush ByteString) m (Flush ByteString)

-- | The standard <a>decompress</a> and <a>ungzip</a> functions will only
--   decompress a single compressed entity from the stream. This combinator
--   will exhaust the stream completely of all individual compressed
--   entities. This is useful for cases where you have a concatenated
--   archive, e.g. <tt>cat file1.gz file2.gz &gt; combined.gz</tt>.
--   
--   Usage:
--   
--   <pre>
--   sourceFile "combined.gz" $$ multiple ungzip =$ consume
--   </pre>
--   
--   This combinator will not fail on an empty stream. If you want to
--   ensure that at least one compressed entity in the stream exists,
--   consider a usage such as:
--   
--   <pre>
--   sourceFile "combined.gz" $$ (ungzip &gt;&gt; multiple ungzip) =$ consume
--   </pre>
multiple :: Monad m => Conduit ByteString m a -> Conduit ByteString m a

-- | This specifies the size of the compression window. Larger values of
--   this parameter result in better compression at the expense of higher
--   memory usage.
--   
--   The compression window size is the value of the the window bits raised
--   to the power 2. The window bits must be in the range <tt>8..15</tt>
--   which corresponds to compression window sizes of 256b to 32Kb. The
--   default is 15 which is also the maximum size.
--   
--   The total amount of memory used depends on the window bits and the
--   <a>MemoryLevel</a>. See the <a>MemoryLevel</a> for the details.
data WindowBits :: *
WindowBits :: Int -> WindowBits

-- | The default <a>WindowBits</a> is 15 which is also the maximum size.
defaultWindowBits :: WindowBits
