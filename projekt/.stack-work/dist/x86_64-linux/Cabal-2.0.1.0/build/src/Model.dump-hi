
==================== FINAL INTERFACE ====================
2018-01-05 20:01:39.585505 UTC

interface projekt-0.1.0.0-Jjh2ddiGNrb2IxTA9KLrW9:Model 8022
  interface hash: 226b9da49a3a3444e547f2cf6560fd5a
  ABI hash: 3f2ba8a93912ae310095ddf0bed6eca7
  export-list hash: 66f36a97b6809f689f320693ab69b647
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 357164054848f7e1885c71f156bb20c5
  sig of: Nothing
  used TH splices: False
  where
exports:
  Model.costFunction
  Model.gradient
  Model.hvec
  Model.hypothesis
  Model.matrixByVector
  Model.readToArray
  Model.sigmoid
  Model.singleGradient
  Model.vectorByVector
module dependencies: Counter
package dependencies: array-0.5.2.0 base-4.10.1.0* deepseq-1.4.3.0
                      directory-1.3.1.5 filepath-1.4.1.2 ghc-prim-0.5.1.1
                      integer-gmp-1.0.1.0 random-1.1* time-1.8.0.2 unix-2.7.2.2
orphans: time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian base-4.10.1.0:GHC.Float
         base-4.10.1.0:GHC.Base
family instance modules: base-4.10.1.0:Control.Applicative
                         base-4.10.1.0:Data.Complex base-4.10.1.0:Data.Either
                         base-4.10.1.0:Data.Functor.Compose base-4.10.1.0:Data.Functor.Const
                         base-4.10.1.0:Data.Functor.Identity
                         base-4.10.1.0:Data.Functor.Product base-4.10.1.0:Data.Functor.Sum
                         base-4.10.1.0:Data.List.NonEmpty base-4.10.1.0:Data.Monoid
                         base-4.10.1.0:Data.Semigroup base-4.10.1.0:Data.Type.Equality
                         base-4.10.1.0:Data.Version base-4.10.1.0:Data.Void
                         base-4.10.1.0:GHC.Exts base-4.10.1.0:GHC.Generics
                         base-4.10.1.0:GHC.IO.Exception base-4.10.1.0:GHC.TypeLits
                         base-4.10.1.0:GHC.TypeNats
import  -/  base-4.10.1.0:Data.Foldable 9ed87455d68e87ff2b5b8725eae9897e
import  -/  base-4.10.1.0:Data.OldList 555420b092ca8cf0a8f9666bc0e07dcf
import  -/  base-4.10.1.0:Data.String 2224f2a50682577469081924dd1e46df
import  -/  base-4.10.1.0:GHC.Base 782fd99b5e36f3698a26179a49afca64
import  -/  base-4.10.1.0:GHC.Float 28e3bf9e258278ac8084e9cab43fd542
import  -/  base-4.10.1.0:GHC.List e3060fbeb44ce0038e6b4dedf2dd9cf1
import  -/  base-4.10.1.0:GHC.Num 6e1dc5d36d99a802edb39b92bb1923b8
import  -/  base-4.10.1.0:GHC.Real 3c62834bc25e762eabc44149c4cc142d
import  -/  base-4.10.1.0:Prelude 31945b7d0084063347fc52506d3a4020
import  -/  base-4.10.1.0:System.IO 6e5bb580370d8d71dc5888f723cea4b4
import  -/  ghc-prim-0.5.1.1:GHC.Classes 93e2660065dce9329577e83d76d8f0d4
import  -/  ghc-prim-0.5.1.1:GHC.Types b1fd0716441595db508c1a74387bf394
import  -/  Counter 533c03f6441a1aa5a30ee941358aaac5
  exports: e1ca87b51ef91e2d442099ba63056a7a
  convertToVec 3069fe9f2732b87c829e50978df00c25
import  -/  random-1.1:System.Random 7425ef878fcdaaac7b607c0c2d51fc7c
bdd9e3c6be9aaf8459cb205bea62e5c5
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Model.$trModule3 Model.$trModule1) -}
85a19d61a8a9e4a1c90d6705485a11af
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Model.$trModule2) -}
16f3ce06b5eae28cc298116bdcd0aa6e
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Model"#) -}
1063ff1237c5a79ac335c5c0fcbe8a4e
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Model.$trModule4) -}
0b706fb09c3881be62cca2eced402520
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("projekt-0.1.0.0-Jjh2ddiGNrb2IxTA9KLrW9"#) -}
c616fa98b28b5544a698f1ea25e4da4f
  $wgradient ::
    GHC.Float.Floating a => [[a]] -> [a] -> [a] -> GHC.Prim.Int# -> [a]
  {- Arity: 5,
     Strictness: <L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),A,A,C(U)),C(C1(U)),A,A),A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><S,U><S,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Float.Floating a)
                   (w1 :: [[a]])
                   (w2 :: [a])
                   (w3 :: [a])
                   (ww :: GHC.Prim.Int#) ->
                 letrec {
                   $wgradient1 :: [[a]] -> [a] -> [a] -> GHC.Prim.Int# -> [a]
                     {- Arity: 4, Strictness: <L,U><L,U><S,U><S,U>, Inline: [0] -}
                   = \ (w4 :: [[a]]) (w5 :: [a]) (w6 :: [a]) (ww1 :: GHC.Prim.Int#) ->
                     case GHC.List.$wlenAcc @ a w6 0# of ww2 { DEFAULT ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.==# ww1 ww2) of wild {
                       GHC.Types.False
                       -> GHC.Types.:
                            @ a
                            (Model.singleGradient @ a w w4 w5 w6 (GHC.Types.I# ww1))
                            ($wgradient1 w4 w5 w6 (GHC.Prim.+# ww1 1#))
                       GHC.Types.True -> GHC.Types.[] @ a } }
                 } in
                 $wgradient1 w1 w2 w3 ww) -}
97f87070fcbe04db8aa11c793edb1b3e
  costFunction :: GHC.Float.Floating a => [[a]] -> [a] -> [a] -> a
  {- Arity: 4,
     Strictness: <S(S(LC(C(S))LL)LLLLLLLLLLLLLLLLLLLLLL),U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),A,A,C(U)),C(C1(U)),A,A),A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U>,
     Unfolding: (\ @ a
                   ($dFloating :: GHC.Float.Floating a)
                   (eta :: [[a]])
                   (eta1 :: [a])
                   (eta2 :: [a]) ->
                 let {
                   $dFractional :: GHC.Real.Fractional a
                   = GHC.Float.$p1Floating @ a $dFloating
                 } in
                 let {
                   $dNum :: GHC.Num.Num a = GHC.Real.$p1Fractional @ a $dFractional
                 } in
                 GHC.Real./
                   @ a
                   $dFractional
                   (GHC.Num.-
                      @ a
                      $dNum
                      (Model.vectorByVector
                         @ a
                         $dNum
                         (GHC.Base.map
                            @ a
                            @ a
                            (\ (x :: a) -> GHC.Num.negate @ a $dNum x)
                            eta1)
                         (GHC.Base.map
                            @ a
                            @ a
                            (GHC.Float.log @ a $dFloating)
                            (Model.hvec @ a $dFloating eta2 eta)))
                      (let {
                         lvl :: a = GHC.Num.fromInteger @ a $dNum Model.costFunction1
                       } in
                       Model.vectorByVector
                         @ a
                         $dNum
                         (GHC.Base.map
                            @ a
                            @ a
                            (\ (x :: a) -> GHC.Num.- @ a $dNum lvl x)
                            eta1)
                         (GHC.Base.map
                            @ a
                            @ a
                            (\ (x :: a) ->
                             GHC.Float.log @ a $dFloating (GHC.Num.- @ a $dNum lvl x))
                            (Model.hvec @ a $dFloating eta2 eta))))
                   (GHC.Num.fromInteger
                      @ a
                      $dNum
                      (case GHC.List.$wlenAcc @ [a] eta 0# of ww2 { DEFAULT ->
                       GHC.Integer.Type.smallInteger ww2 }))) -}
04418bf101cdf5ab740ef0f4480470d6
  costFunction1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (1) -}
ff77e0ec5b93082bcff5e2cef80436be
  gradient ::
    GHC.Float.Floating a => [[a]] -> [a] -> [a] -> GHC.Types.Int -> [a]
  {- Arity: 5,
     Strictness: <L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),A,A,C(U)),C(C1(U)),A,A),A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><S,U><S(S),1*U(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ a
                   (w :: GHC.Float.Floating a)
                   (w1 :: [[a]])
                   (w2 :: [a])
                   (w3 :: [a])
                   (w4 :: GHC.Types.Int) ->
                 case w4 of ww { GHC.Types.I# ww1 ->
                 Model.$wgradient @ a w w1 w2 w3 ww1 }) -}
fbfc4bc24a20713bc110928d4e765e52
  hvec :: GHC.Float.Floating a => [a] -> [[a]] -> [a]
  {- Arity: 3,
     Strictness: <L,U(U(U(C(C1(U)),A,C(C1(U)),C(U),A,A,C(U)),C(C1(U)),A,A),A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><S,1*U> -}
b31835623574709fd62c81fb37c962b3
  hypothesis :: GHC.Float.Floating a => [a] -> [a] -> a
  {- Arity: 3,
     Strictness: <S(S(LC(C(S))LL)LLLLLLLLLLLLLLLLLLLLLL),U(U(U(C(C1(U)),A,C(C1(U)),C(U),A,A,C(U)),C(C1(U)),A,A),A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
     Unfolding: (\ @ a
                   ($dFloating :: GHC.Float.Floating a)
                   (eta :: [a])
                   (eta1 :: [a]) ->
                 Model.sigmoid
                   @ a
                   $dFloating
                   (Model.vectorByVector
                      @ a
                      (GHC.Real.$p1Fractional @ a (GHC.Float.$p1Floating @ a $dFloating))
                      eta
                      eta1)) -}
720e783272b6e3c890d38d3f14170a58
  matrixByVector :: GHC.Num.Num a => [[a]] -> [a] -> [a]
  {- Arity: 3,
     Strictness: <L,U(C(C1(U)),A,C(C1(U)),A,A,A,C(U))><S,1*U><L,U>,
     Unfolding: (\ @ a
                   ($dNum :: GHC.Num.Num a)
                   (eta :: [[a]])
                   (eta1 :: [a]) ->
                 letrec {
                   matrixByVector1 :: [[a]] -> [a] -> [a]
                     {- Arity: 2, Strictness: <S,1*U><L,U> -}
                   = \ (ds :: [[a]]) (ds1 :: [a]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ a
                       : ipv ipv1
                       -> GHC.Types.:
                            @ a
                            (Model.vectorByVector @ a $dNum ipv ds1)
                            (matrixByVector1 ipv1 ds1) }
                 } in
                 matrixByVector1 eta eta1) -}
c2244ede1dde66d75c088539ea1fe510
  readToArray ::
    GHC.Types.IO
      ([[GHC.Integer.Type.Integer]], [GHC.Integer.Type.Integer])
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Model.readToArray1
                  `cast`
                (Sym (GHC.Types.N:IO[0]
                          <([[GHC.Integer.Type.Integer]], [GHC.Integer.Type.Integer])>_R)) -}
74a0010269c44c85de6072af05e0cde5
  readToArray1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          ([[GHC.Integer.Type.Integer]], [GHC.Integer.Type.Integer]) #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case GHC.IO.Handle.FD.openFile1
                        Model.readToArray6
                        GHC.IO.IOMode.ReadMode
                        s of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.Text.hGetContents1
                        ipv1
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 case GHC.IO.Handle.FD.openFile1
                        Model.readToArray4
                        GHC.IO.IOMode.ReadMode
                        ipv2 of ds3 { (#,#) ipv4 ipv5 ->
                 case GHC.IO.Handle.Text.hGetContents1
                        ipv5
                        ipv4 of ds4 { (#,#) ipv6 ipv7 ->
                 case GHC.IO.Handle.FD.openFile1
                        Model.readToArray2
                        GHC.IO.IOMode.ReadMode
                        ipv6 of ds5 { (#,#) ipv8 ipv9 ->
                 case GHC.IO.Handle.Text.hGetContents1
                        ipv9
                        ipv8 of ds6 { (#,#) ipv10 ipv11 ->
                 (# ipv10,
                    (GHC.Base.map
                       @ [GHC.Types.Char]
                       @ [GHC.Integer.Type.Integer]
                       (let {
                          f :: [GHC.Base.String] = Data.OldList.words ipv11
                        } in
                        \ (x :: [GHC.Types.Char]) ->
                        Counter.convertToVec
                          @ GHC.Base.String
                          @ GHC.Integer.Type.Integer
                          GHC.Num.$fNumInteger
                          GHC.Classes.$fEq[]_$s$fEq[]1
                          f
                          (Data.OldList.words x))
                       (Data.OldList.lines ipv3),
                     case GHC.List.$wlenAcc
                            @ [GHC.Types.Char]
                            (Data.OldList.lines ipv3)
                            0# of ww2 { DEFAULT ->
                     let {
                       n :: [GHC.Integer.Type.Integer]
                       = case GHC.List.$wlenAcc
                                @ [GHC.Types.Char]
                                (Data.OldList.lines ipv7)
                                0# of ww1 { DEFAULT ->
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># 1# ww1) of wild {
                           GHC.Types.False
                           -> letrec {
                                go :: GHC.Prim.Int# -> [GHC.Integer.Type.Integer]
                                  {- Arity: 1, Strictness: <L,U> -}
                                = \ (x :: GHC.Prim.Int#) ->
                                  GHC.Types.:
                                    @ GHC.Integer.Type.Integer
                                    Model.vectorByVector1
                                    (case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.==# x ww1) of wild1 {
                                       GHC.Types.False -> go (GHC.Prim.+# x 1#)
                                       GHC.Types.True -> GHC.Types.[] @ GHC.Integer.Type.Integer })
                              } in
                              go 1#
                           GHC.Types.True -> GHC.Types.[] @ GHC.Integer.Type.Integer } }
                     } in
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.># 1# ww2) of wild {
                       GHC.Types.False
                       -> letrec {
                            go :: GHC.Prim.Int# -> [GHC.Integer.Type.Integer]
                              {- Arity: 1, Strictness: <L,U> -}
                            = \ (x :: GHC.Prim.Int#) ->
                              GHC.Types.:
                                @ GHC.Integer.Type.Integer
                                Model.costFunction1
                                (case GHC.Prim.tagToEnum#
                                        @ GHC.Types.Bool
                                        (GHC.Prim.==# x ww2) of wild1 {
                                   GHC.Types.False -> go (GHC.Prim.+# x 1#) GHC.Types.True -> n })
                          } in
                          go 1#
                       GHC.Types.True -> n } }) #) } } } } } }) -}
34eda82ba986a0f20fe70dcb17a36519
  readToArray2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Model.readToArray3) -}
6bc0a40e1dfd94c1bebb12e1e4738ca0
  readToArray3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("HamSpamDiffrence"#) -}
e247996699fb543457ded3b1761b696a
  readToArray4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Model.readToArray5) -}
8f04613d9ec359b4b4be2c1868a5ee00
  readToArray5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("HamEmails"#) -}
21988fa48e52da259c1fef6c2a54f080
  readToArray6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Model.readToArray7) -}
f77ab158860918d1a1033c11d023486b
  readToArray7 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("SpamEmails"#) -}
78fab7c2f5573564e007d41d095cbe28
  sigmoid :: GHC.Float.Floating a => a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(LC(C(S))LL)LLLLLLLLLLLLLLLLLLLLLL),U(1*U(1*U(1*C1(C1(U)),A,A,1*C1(U),A,A,C(U)),1*C1(C1(U)),A,A),A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
     Unfolding: (\ @ a
                   ($dFloating :: GHC.Float.Floating a)
                   (eta :: a) ->
                 let {
                   $dFractional :: GHC.Real.Fractional a
                   = GHC.Float.$p1Floating @ a $dFloating
                 } in
                 let {
                   $dNum :: GHC.Num.Num a = GHC.Real.$p1Fractional @ a $dFractional
                 } in
                 GHC.Real./
                   @ a
                   $dFractional
                   (GHC.Num.fromInteger @ a $dNum Model.costFunction1)
                   (GHC.Num.+
                      @ a
                      $dNum
                      (GHC.Num.fromInteger @ a $dNum Model.costFunction1)
                      (GHC.Float.exp @ a $dFloating (GHC.Num.negate @ a $dNum eta)))) -}
40127a4c9d2d23d12c450e72d61b7db7
  singleGradient ::
    GHC.Float.Floating a => [[a]] -> [a] -> [a] -> GHC.Types.Int -> a
  {- Arity: 5,
     Strictness: <S(S(LC(C(S))LL)LLLLLLLLLLLLLLLLLLLLLL),U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),A,A,C(U)),C(C1(U)),A,A),A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,1*U><L,U><L,U(U)>,
     Unfolding: (\ @ a
                   ($dFloating :: GHC.Float.Floating a)
                   (eta :: [[a]])
                   (eta1 :: [a])
                   (eta2 :: [a])
                   (eta3 :: GHC.Types.Int) ->
                 let {
                   $dFractional :: GHC.Real.Fractional a
                   = GHC.Float.$p1Floating @ a $dFloating
                 } in
                 let {
                   $dNum :: GHC.Num.Num a = GHC.Real.$p1Fractional @ a $dFractional
                 } in
                 GHC.Real./
                   @ a
                   $dFractional
                   (letrec {
                      vectorMinusvector :: [a] -> [a] -> [a]
                        {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                      = \ (ds :: [a]) (ds1 :: [a]) ->
                        case ds of wild {
                          [] -> GHC.Types.[] @ a
                          : ipv ipv1
                          -> case ds1 of wild1 {
                               [] -> GHC.Types.[] @ a
                               : ipv2 ipv3
                               -> GHC.Types.:
                                    @ a
                                    (GHC.Num.- @ a $dNum ipv ipv2)
                                    (vectorMinusvector ipv1 ipv3) } }
                    } in
                    letrec {
                      go2 :: [a] -> [a] -> a -> a
                        <join 3> {- Arity: 3, Strictness: <S,1*U><L,1*U><L,U> -}
                      = \ (ds :: [a]) (_ys :: [a]) (eta4 :: a) ->
                        case ds of wild {
                          [] -> eta4
                          : ipv ipv1
                          -> case _ys of wild1 {
                               [] -> eta4
                               : ipv2 ipv3
                               -> go2
                                    ipv1
                                    ipv3
                                    (GHC.Num.+ @ a $dNum eta4 (GHC.Num.* @ a $dNum ipv ipv2)) } }
                    } in
                    go2
                      (vectorMinusvector (Model.hvec @ a $dFloating eta2 eta) eta1)
                      (Model.singleGradient_nVecFromVectors @ a eta eta3)
                      (GHC.Num.fromInteger @ a $dNum Model.vectorByVector1))
                   (GHC.Num.fromInteger
                      @ a
                      $dNum
                      (case GHC.List.$wlenAcc @ [a] eta 0# of ww2 { DEFAULT ->
                       GHC.Integer.Type.smallInteger ww2 }))) -}
48bd67d37da939ced55bda11d8c60786
  singleGradient_nVecFromVectors :: [[a]] -> GHC.Types.Int -> [a]
  {- Arity: 2, Strictness: <S,1*U><L,U(U)> -}
4374d04e2a27e91ff7d95b248c773d59
  vectorByVector :: GHC.Num.Num p => [p] -> [p] -> p
  {- Arity: 3,
     Strictness: <L,U(C(C1(U)),A,C(C1(U)),A,A,A,1*C1(U))><S,U><L,U>,
     Unfolding: (\ @ p
                   ($dNum :: GHC.Num.Num p)
                   (eta :: [p])
                   (eta1 :: [p]) ->
                 let {
                   lvl :: p = GHC.Num.fromInteger @ p $dNum Model.vectorByVector1
                 } in
                 letrec {
                   vectorByVector2 :: [p] -> [p] -> p
                     {- Arity: 2, Strictness: <S,U><L,U> -}
                   = \ (ds :: [p]) (ds1 :: [p]) ->
                     let {
                       fail :: GHC.Prim.Void# -> p
                         <join 1> {- Arity: 1, Strictness: <L,A> -}
                       = \ (ds2 :: GHC.Prim.Void#)[OneShot] ->
                         GHC.Num.+
                           @ p
                           $dNum
                           (GHC.Num.*
                              @ p
                              $dNum
                              (case ds of wild { [] -> GHC.List.badHead @ p : x ds3 -> x })
                              (case ds1 of wild { [] -> GHC.List.badHead @ p : x ds3 -> x }))
                           (case ds of wild {
                              [] -> case GHC.List.scanl2 ret_ty p of {}
                              : ds3 xs
                              -> vectorByVector2
                                   xs
                                   (case ds1 of wild1 {
                                      [] -> GHC.List.scanl2 @ p : ds4 xs1 -> xs1 }) })
                     } in
                     case ds of wild {
                       []
                       -> case ds1 of wild1 {
                            [] -> lvl : ipv ipv1 -> fail GHC.Prim.void# }
                       : ipv ipv1 -> fail GHC.Prim.void# }
                 } in
                 vectorByVector2 eta eta1) -}
8658c5b0c1e8ea1e7a85a66aef8919ff
  vectorByVector1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (0) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

