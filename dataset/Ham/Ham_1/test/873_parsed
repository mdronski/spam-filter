 from email wed sep number number number return-path email delivered-to email receiv from localhost (jalapeno number by jmason.org (postfix) with esmtp id number for email wed number sep number number number (ist) receiv from jalapeno number by localhost with imap number for email (single-drop) wed number sep number number number (ist) receiv from xent.com number by dogma.slashnull.org number with esmtp id number for email wed number sep number number number receiv from lair.xent.com (localhost number by xent.com (postfix) with esmtp id number tue number sep number number number (pdt) delivered-to email receiv from mithral.com (watcher.mithral.com number by xent.com (postfix) with smtp id number for email tue number sep number number number (pdt) receiv (qmail number invok by uid number number sep number number number from "adam l beberg" email to kragen sitak email cc email subject re asynchron i/o (was re gasp!) in-reply-to email message-id email mime-vers number content-typ text/plain charset=us-ascii sender email errors-to email x-beenther email x-mailman-vers number preced bulk list-help email list-post email list-subscrib URL email list-id friend of rohit khare  list-unsubscrib URL email list-arch URL date tue number sep number number number (pdt) on tue number sep number kragen sitak wrote  of cours we'v had select() sinc bsd number and poll() sinc system v  or so and they work reason well for asynchron i/o up to a  hundr or so channel but suck after that /dev/pol (avail in  solari and linux) is one approach to solv this linux has a way to  do essenti the same thing with real-tim signal and has for  year and freebsd has kqueue   more detail about these are at  URL   none of this help with disk i/o most program that need to overlap  disk i/o with comput on either proprietari unix or linux just  use multipl thread or process to handl the disk i/o   posix specifi a mechan for nonblock disk i/o that most  proprietari unix implement the linux kernel hacker are current  rewrit linux entir i/o subsystem essenti from scratch to  work asynchron becaus they can easili build effici  synchron i/o primit from asynchron one but not the other  way around so now linux will support this mechan too   it probabl doesn't need say for anyon who read beberg say  thing like "memori manag is a non-issu for anyon that has ani  idea at all how the hardwar functions," but he total off-bas  peopl should know by now not to take anyth he say serious but  appar some don't so i'll rebut   not surpris the rebutt requir mani more word than the  origin stupid error   in detail he wrote   could it be after number year without this featur unix final   catch up to window and has i/o that doesnt [sic] total suck for   nontrivi app no way   unix acquir nonblock i/o in the form of select() about number year  ago and solari has had the particular aio_* call we are discuss  for mani year veri few applic need the aio_* call ---  essenti onli high-perform rdbms server even benefit from them  at all and most of those have been fake it fine for a while with  multipl thread or process this just provid a modicum of extra  perform    ok so they do it with signal or a flag which is complet   ghetto but at least they are tri keep tri guy you got the   idea but not the clue   reader can judg who lack the clue here    the window i/o model doe defin [sic] blow the door off the   unix one but then they had select to point at in it [sic]   sucki and anyth would have been an improv unix is just   now look at it [sic] i/o model and adapt to a multiprocess   multithread world so it gonna be year yet befor a posix api   come out of it   although i don't have a copi of the spec handi i think the aio_* api  come from the posix spec ieee std number section number which is  number year old and which i think document then-curr practic  they might be even older than that   unix has been multiprocess sinc number and most unix implement  have support multithread for a decad or more    bottom line is the "do stuff when someth happens" model turn   out to be right and the unix "look for someth to do and keep   look till you find it no matter how mani time you have to look"   is not realli work so great anymor   linux aio_* routin can notifi the process of their complet with  a "signal" a featur miss in microsoft window a "signal" caus  the immedi execut of a "signal handler" in a process by  contrast the microsoft window mechan to do similar thing (such  as complet ports) do not deliv a notif until the process  poll them   i don't think signal are a better way to do thing in this case  (although i haven't written ani rdbmses myself) but you got the  technic descript of the two oper system exact backward  most program that use linux real-tim signal for asynchron  network i/o in fact block the signal in question and poll the signal  queue in a veri windowsish way use sigtimedwait() or sigwaitinfo()   --  email kragen sitak URL  edsger wybe dijkstra die in august of number this is a terribl loss after  which the world will never be the same  number  - adam l "duncan" beberg URL email